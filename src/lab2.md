以下是你提供的英文说明的中文翻译：

---

### 简介

在本实验中，你将构建一个**单机上的键值服务器（key/value server）**，该服务器需要保证每个操作即使在网络出现故障时也**恰好执行一次（exactly-once）**，并且这些操作是**线性一致（linearizable）**的。后续的实验将会对这种服务器进行复制，以处理服务器崩溃的情况。

客户端可以向键值服务器发送三种不同的 RPC 请求：

- `Put(key, value)`：将某个 key 对应的值设为 value（若已存在则替换）；
- `Append(key, arg)`：将 arg 附加到 key 对应的值后面，并返回原始值；
- `Get(key)`：获取 key 当前的值。

服务器维护一个内存中的键值对映射（map），key 和 value 都是字符串类型。  
- 对于不存在的 key，`Get()` 应该返回空字符串；  
- 对不存在的 key 进行 `Append()`，应当视为该 key 的初始值为空字符串。

每个客户端通过一个 `Clerk` 与服务器通信，Clerk 提供 `Put`、`Append` 和 `Get` 方法，用于管理与服务器的 RPC 交互。

你实现的服务器必须确保对 Clerk 的 Get/Put/Append 方法的调用是**线性一致的**。  
- 如果客户端请求**不是并发的**，每个调用都应该观察到先前调用对状态的更改；
- 如果调用是**并发的**，返回结果与最终状态必须和某种串行执行顺序等价。

调用是并发的，当它们在时间上**重叠**，例如：  
客户端 X 调用 `Clerk.Put()`，客户端 Y 调用 `Clerk.Append()`，而后 X 的调用返回，这两个调用就是并发的。每个调用必须观察在它开始之前已经完成的所有调用的效果。

线性一致性对应用程序非常友好，因为这就像只有一个按顺序处理请求的单个服务器。例如：如果一个客户端成功完成一次更新请求，其他客户端随后发起的读取请求就**必须能看到这次更新的效果**。在单服务器场景下，实现线性一致性相对容易。

---

### 快速开始

我们在 `src/kvsrv` 目录下为你提供了骨架代码和测试。你需要修改以下文件：

- `kvsrv/client.go`
- `kvsrv/server.go`
- `kvsrv/common.go`

要开始实验，请执行以下命令（注意执行 `git pull` 以获取最新代码）：

```bash
$ cd ~/6.5840
$ git pull
...
$ cd src/kvsrv
$ go test
...
```

---

### 无网络故障的键值服务器（简单）

你的第一个任务是实现一个在**无消息丢失**情况下工作的解决方案。

你需要：

- 在 `client.go` 中 Clerk 的 Put/Append/Get 方法里添加 RPC 发送代码；
- 在 `server.go` 中实现对应的 Put、Append 和 Get RPC 处理函数。

当你通过测试集中前两个测试用例时（"one client" 和 "many clients"），就表示完成了这部分任务。

你可以通过以下命令检查是否存在数据竞争：

```bash
go test -race
```

---

### 有消息丢失的键值服务器（简单）

接下来，你需要修改代码以在出现**消息丢失**时依然能正常工作（例如 RPC 请求或回复丢失）。

如果消息丢失，客户端调用 `ck.server.Call()` 会返回 false（Call 会在一定超时时间内等待回复，如果超时未收到，则返回 false）。

你需要处理的一个关键问题是：Clerk 可能会多次发送同一个 RPC 请求，但服务器必须**只执行一次**。  
- 因此你必须确保即使重发，服务器也不会重复执行相同的操作。

你需要：

- 在 Clerk 中添加重试逻辑（如果没收到回复就重发）；
- 在 `server.go` 中添加去重逻辑，以过滤掉重复的操作（必要时）；

这些说明中包含了有关重复检测的提示。

为确保每个客户端操作只被执行一次，你需要给每个操作分配唯一的标识符（如操作 ID）。

你需要仔细思考服务器需要记录哪些状态，来处理重复的 Get()、Put() 和 Append() 请求（可能并不都需要记录）。

你设计的去重机制还应该尽快释放服务器内存，例如可以通过每个 RPC 隐式表明客户端已收到上一个 RPC 的回复来实现。  
可以假设客户端一次只会对 Clerk 发起一个请求。

---

完成后，你的程序应该能通过所有测试，如下所示：

```bash
$ go test
Test: one client ...
  ... Passed -- t  3.8 nrpc 31135 ops 31135
Test: many clients ...
  ... Passed -- t  4.7 nrpc 102853 ops 102853
Test: unreliable net, many clients ...
  ... Passed -- t  4.1 nrpc   580 ops  496
Test: concurrent append to same key, unreliable ...
  ... Passed -- t  0.6 nrpc    61 ops   52
Test: memory use get ...
  ... Passed -- t  0.4 nrpc     4 ops    0
Test: memory use put ...
  ... Passed -- t  0.2 nrpc     2 ops    0
Test: memory use append ...
  ... Passed -- t  0.4 nrpc     2 ops    0
Test: memory use many puts ...
  ... Passed -- t 11.5 nrpc 100000 ops    0
Test: memory use many gets ...
  ... Passed -- t 12.2 nrpc 100001 ops    0
PASS
ok      6.5840/kvsrv    39.000s
```

每个 “Passed” 后面的数字表示：
- **耗时（秒）**
- **RPC 总调用数（含客户端重试）**
- **实际执行的键值操作次数（Clerk 的 Get/Put/Append 调用次数）**

---

### 实现重点
1. 线性一致：
    * 即强一致性， 假设我们有一个分布式键值存储系统，客户端A写入了一个新的值 key=1, value=A，如果这个操作是线性一致的，那么在此操作之后，所有其他客户端（包括B、C）都将看到 key=1, value=A，并且在操作A之前的操作（如果有）不会影响它。  
2. 保证每个操作在网络出现故障的时候也恰好执行一次：
    * 对于每个客户端的每个请求都标注一个唯一的ID，即使用（客户端ID：请求序列号）二元组信息
3. 检测并过滤重复操作：
    * 每个客户端记录请求的递增序列号，来确保服务端可以识别重复请求
    * 服务器跟踪为每个客户机处理的最高序列号。如果接收到的请求序列号小于或等于已处理的最高序列号，则将其视为重复请求，服务器将返回存储的响应，而无需重新处理该请求。
4. 确保在并发的情况下顺序是一致的：
    * 加锁就完事儿了。